# Конституция проекта Project Progress

## Основные принципы

### I. Type Safety First (НЕПРЕМЕННО)
Весь код ДОЛЖЕН быть написан на TypeScript со строгой проверкой типов. Типы `any` запрещены без явного обоснования. Все ответы API, props компонентов и state должны иметь определённые типы. Type definitions для Kaiten API должны быть сгенерированы или поддерживаться вручную для обеспечения type safety на уровне интеграции.

### II. Component-Based Architecture
React компоненты ДОЛЖНЫ быть самодостаточными, переиспользуемыми и следовать принципу единственной ответственности. Каждый компонент должен иметь чёткий интерфейс props, правильные error boundaries и состояния загрузки. Ячейки таймлайна, карточки этапов и представления проектов должны быть реализованы как независимые, тестируемые компоненты.

### III. Стандарты интеграции с API
Интеграция с Kaiten API ДОЛЖНА быть абстрагирована за service layer. Все вызовы API должны обрабатывать ошибки корректно, реализовывать retry logic для временных сбоев и кэшировать ответы соответствующим образом. Синхронизация API должна быть двунаправленной, где это возможно, с чёткими стратегиями разрешения конфликтов. Для read-only источников данных (например, Kaiten API, где приложение не владеет данными и только читает задачи) синхронизация односторонняя (read-only). При создании проекта этапы и задачи из Kaiten API ДОЛЖНЫ быть привязаны немедленно.

### IV. Консистентность UI/UX
Все UI компоненты ДОЛЖНЫ следовать design system из Figma UI kit, доступного через Figma MCP. Запрещено кастомное стилизование, отклоняющееся от design system без явного одобрения. Интерактивные элементы (кнопки, inputs, модальные окна) должны поддерживать консистентное поведение и визуальный вид во всём приложении.
- UI-kit: https://www.figma.com/design/pj5aiXE1X40rEoVbtyVQ2F/Turbo?node-id=0-1

### V. Масштабируемость и расширяемость
Архитектура ДОЛЖНА поддерживать будущее расширение: новые типы задач, дополнительные функции управления проектами и улучшения интерфейса. Организация кода должна разделять concerns (data layer, presentation layer, business logic). Configuration и feature flags должны использоваться для постепенного внедрения новых возможностей.

### VI. Целостность синхронизации данных
Визуализация таймлайна ДОЛЖНА точно отражать статус задач из Kaiten API. Состояния завершения и паузы этапов должны синхронизироваться двунаправленно. Параллельные этапы с перекрывающимися таймлайнами должны корректно отображаться без визуальных конфликтов. Расчёт прогресса должен основываться на фактическом статусе выполнения задач, а не только на локальном state.

## Требования к технологическому стеку

- **Frontend Framework**: React с TypeScript (strict mode)
- **Интеграция с API**: REST API для интеграции с Kaiten
- **Backend/Storage**: Firebase или эквивалентный cloud backend для хранения данных
- **Design System**: Компоненты Figma UI kit через Figma MCP
- **State Management**: React hooks и context API (или Redux при необходимости)
- **Аутентификация**: Контроль доступа по паролю для веб-приложения

## Процесс разработки

### Quality Gates для кода
- Все компоненты должны иметь определённые TypeScript типы
- Методы API service должны включать обработку ошибок и определения типов
- Логика рендеринга таймлайна должна быть покрыта unit тестами
- Integration тесты обязательны для потоков синхронизации Kaiten API

### Процесс ревью
- PR должны проверять соответствие Figma design system
- Изменения интеграции API требуют покрытия integration тестами
- Новые типы задач или функции управления этапами должны включать план миграции
- Необходимо оценивать влияние на производительность при рендеринге таймлайна с большими наборами данных

### Требования к тестированию
- Unit тесты для business logic (расчёты этапов, отслеживание прогресса)
- Integration тесты для синхронизации Kaiten API
- Visual regression тесты для рендеринга таймлайна
- E2E тесты для критических пользовательских сценариев (создание проекта, обновление этапа, просмотр таймлайна)

## Управление

Эта конституция имеет приоритет над всеми остальными практиками разработки. Все PR и code review должны проверять соответствие этим принципам. Сложность должна быть обоснована чёткой аргументацией. Изменения в конституцию требуют:
1. Документирования обоснования изменения
2. Анализа влияния на существующую codebase
3. Плана миграции при внесении breaking changes
4. Увеличения версии по правилам semantic versioning (MAJOR.MINOR.PATCH)

**Версия**: 1.0.1 | **Ратифицирована**: 2025-02-02 | **Последнее изменение**: 2025-02-02
